From 2b0840f907a1e69f05a740a13df515dfa80ebf02 Mon Sep 17 00:00:00 2001
From: Szymon Sliwa <szs@semihalf.com>
Date: Thu, 22 Feb 2018 14:41:35 +0100
Subject: [PATCH 4/4] [HACK] enable inline for odp-dpdk

Added simple lines which enable IPsec inline mode
on RX using socket pktio. The changes are not intended to be
pushed to main odp repository - these are only minimal changes
to make use of the functionality.

Signed-off-by: Szymon Sliwa <szs@semihalf.com>
---
 platform/linux-dpdk/odp_packet_dpdk.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/platform/linux-dpdk/odp_packet_dpdk.c b/platform/linux-dpdk/odp_packet_dpdk.c
index a660fe3..8e7a2db 100644
--- a/platform/linux-dpdk/odp_packet_dpdk.c
+++ b/platform/linux-dpdk/odp_packet_dpdk.c
@@ -30,6 +30,7 @@
 #include <odp/api/system_info.h>
 #include <odp_debug_internal.h>
 #include <odp_classification_internal.h>
+#include <odp_ipsec_internal.h>
 #include <odp_packet_io_internal.h>
 #include <odp_packet_dpdk.h>
 #include <net/if.h>
@@ -219,6 +220,9 @@ static int setup_pkt_dpdk(odp_pktio_t pktio ODP_UNUSED, pktio_entry_t *pktio_ent
 	pktio_entry->s.capa.max_output_queues = RTE_MIN(dev_info.max_tx_queues,
 							PKTIO_MAX_QUEUES);
 
+        pktio_entry->s.capa.config.inbound_ipsec = 1;
+        pktio_entry->s.capa.config.outbound_ipsec = 1;
+
 	mtu = mtu_get_pkt_dpdk(pktio_entry);
 	if (mtu == 0) {
 		ODP_ERR("Failed to read interface MTU\n");
@@ -500,6 +504,20 @@ static int recv_pkt_dpdk(pktio_entry_t *pktio_entry, int index,
 		nb_rx = success;
 	}
 
+	/* Try IPsec inline processing */
+	for (i = 0; i < nb_rx; i++) {
+		odp_packet_t pkt = pkt_table[i];
+		odp_packet_hdr_t *pkt_hdr = odp_packet_hdr(pkt);
+
+		packet_parse_layer(pkt_hdr, ODP_PROTO_LAYER_L4);
+
+		//printf("try ipsec\n");
+
+		if(odp_packet_has_ipsec(pkt_table[i]))
+			_odp_ipsec_try_inline(pkt_table[i]);
+
+	}
+
 	return nb_rx;
 }
 
-- 
2.7.4

